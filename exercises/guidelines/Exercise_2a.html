<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Miquel De Cáceres">
<meta name="dcterms.date" content="2022-06-14">

<title>Exercise 2a guidelines</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Exercise_2a_files/libs/clipboard/clipboard.min.js"></script>
<script src="Exercise_2a_files/libs/quarto-html/quarto.js"></script>
<script src="Exercise_2a_files/libs/quarto-html/popper.min.js"></script>
<script src="Exercise_2a_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Exercise_2a_files/libs/quarto-html/anchor.min.js"></script>
<link href="Exercise_2a_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Exercise_2a_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Exercise_2a_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Exercise_2a_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Exercise_2a_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Exercise 2a guidelines</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Miquel De Cáceres </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 14, 2022</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="exercise-objectives" class="level2">
<h2 class="anchored" data-anchor-id="exercise-objectives">Exercise objectives</h2>
<ol type="1">
<li>Perform a basic water balance run on a real-case data and inspect the results</li>
<li>Evaluate the performance of the water balance model with observed data</li>
<li>Perform an advanced water balance run on the same data and inspect the results</li>
<li>Compare the results and performance between the two models</li>
</ol>
</section>
<section id="exercise-data" class="level2">
<h2 class="anchored" data-anchor-id="exercise-data">Exercise data</h2>
<section id="font-blanche-research-forest" class="level3">
<h3 class="anchored" data-anchor-id="font-blanche-research-forest">Font-Blanche research forest</h3>
<ul>
<li>The Font-Blanche research forest is located in southeastern France (43º14’27’’ N 5°40’45’’ E) at 420 m elevation)</li>
<li>The stand is composed of a top strata of <em>Pinus halepensis</em> (Aleppo pine) reaching about 12 m, a lower strata of <em>Quercus ilex</em> (holm oak), reaching about 6 m, and an understorey strata dominated by <em>Quercus coccifera</em> and <em>Phillyrea latifolia</em>.</li>
<li>Soils are shallow and rocky, have a low retention capacity and are of Jurassic limestone origin.</li>
<li>The climate is Mediterranean, with a water stress period in summer, cold or mild winters and most precipitation occurring between September and May.</li>
</ul>
</section>
<section id="target-stand" class="level3">
<h3 class="anchored" data-anchor-id="target-stand">Target stand</h3>
<ul>
<li><p>The experimental site, which is dedicated to study forest carbon and water cycles, has an enclosed area of 80×80 m but our target stand is a quadrat of dimensions 25×25 m.</p></li>
<li><p>The following observations are available for year 2014:</p>
<ul>
<li>Canopy-level evapotranspiration estimated using an Eddy-covariance flux tower.</li>
<li>Soil water content (SWC) of the topmost (0-30 cm) layer.</li>
<li>Transpiration (E) estimates per leaf area, derived from sapflow measurements for <em>Q. ilex</em> and <em>P. halepensis</em>.</li>
<li>Pre-dawn (PD) and midday (MD) leaf water potentials for <em>Q. ilex</em> and <em>P. halepensis</em>.</li>
</ul></li>
</ul>
</section>
</section>
<section id="guidelines-by-steps" class="level2">
<h2 class="anchored" data-anchor-id="guidelines-by-steps">Guidelines by steps</h2>
<ol type="1">
<li>Load the file <code>"fontblanche.rds"</code>, which contains all the necessary data, and inspect the list elements until you understand them</li>
</ol>
<ol start="2" type="1">
<li>Build a <code>forest</code> object including the three tree cohorts given in the input data and examine its properties (e.g.&nbsp;basal area, tree density and leaf area index).</li>
</ol>
<ol start="3" type="1">
<li>Initialize an object <code>soil</code> using the physical soil description included in the input data.</li>
</ol>
<ol start="4" type="1">
<li>Inspect the data frame <code>customParams</code> and modify the default species parameter table provided in medfate (<em>hint</em>: use function <code>modifySpParams()</code>).</li>
</ol>
<ol start="5" type="1">
<li>Assemble a water balance input object and examine the dates of the weather dataset included in the input data</li>
</ol>
<ol start="6" type="1">
<li>Run a basic water balance simulation and make sure you understand the console output</li>
</ol>
<ol start="7" type="1">
<li>Compare the precipitation events and the generation of surface runoff and/or deep drainage (<em>hint</em>: use functions <code>plot()</code> or <code>shinyplot()</code> for objects <code>spwb</code>).</li>
</ol>
<ol start="8" type="1">
<li>Examine the evapotranspiration flows (intercepted water, plant transpiration, bare soil evaporation), their seasonality and importance for the overall evapotranspiration (<em>hint</em>: use functions <code>plot()</code> or <code>shinyplot()</code> for objects <code>spwb</code>).</li>
</ol>
<ol start="9" type="1">
<li>Examine the dynamics of water potential in the different soil layers. Which ones are more dynamic? What could be wrong in the model parameterization if our expectations in this respect were not met? (<em>hint</em>: use functions <code>plot()</code> or <code>shinyplot()</code> for objects <code>spwb</code>)</li>
</ol>
<ol start="10" type="1">
<li>Examine the observed (measured) data set. Make sure you understand the column names. Try plotting a comparison of the observed vs.&nbsp;simulated stand evapotranspiration (<em>hint</em>: see documentation for function <code>evaluation_plot()</code>).</li>
</ol>
<ol start="11" type="1">
<li>Generate the evaluation statistics for the evapotranspiration comparison (<em>hint</em>: use function <code>evaluation_stats()</code>)</li>
</ol>
<ol start="12" type="1">
<li>Compare the observed vs.&nbsp;simulated soil water content. Why are the two series not scaled? Calculate evaluation statistics.</li>
</ol>
<ol start="13" type="1">
<li>Create a new water balance input object for the advanced model (i.e.&nbsp;use <code>transpirationMode = "Sperry"</code>) and launch a new water balance simulation (this will take some time).</li>
</ol>
<ol start="14" type="1">
<li>Compare the performance of the first simulation to the second, in terms of their fit to observed soil moisture and stand evapotranspiration data.</li>
</ol>
<ol start="15" type="1">
<li>Compare the soil layer moisture dynamics of the two simulations. Which model produces stronger coupling between soil layers? Why?</li>
</ol>
<ol start="16" type="1">
<li>Using the results of the advanced water balance model, draw the plant extraction from soil layers (<code>type = "PlantExtraction"</code>) and the water input from hydraulic redistribution (<code>type = "HydraulicRedistribution"</code>) to understand the upward and downward water flows.</li>
</ol>
<ol start="17" type="1">
<li>Compare the plant transpiration dynamics of the two simulations at the leaf area level. Which species starts closing its stomata earlier? Are the two models consistent in this respect? Which functional parameters govern plant transpiration dynamics?</li>
</ol>
<ol start="18" type="1">
<li>Evaluate the plant transpiration flows predicted by the advanced model for <em>Pinus halepensis</em> and <em>Quercus ilex</em> using observed sap-flow data. For which species does the model perform better in terms of absolute values? For which species is the correlation between observed and simulated values higher?</li>
</ol>
<ol start="19" type="1">
<li>Draw the daily drop in leaf water potential predicted by the advanced model for the three species in the stand (<em>hint</em>: use <code>type = "LeafPsiRange"</code>). Which species has strongest stomatal control?</li>
</ol>
<ol start="20" type="1">
<li>Compare the predicted vs.&nbsp;observed leaf water potentials (pre-dawn and midday). Is the model appropriately estimating leaf water potential dynamics with the amount of information available?</li>
</ol>
<ol start="21" type="1">
<li>Examine the seasonality of plant drought stress (as defined in the model) and stem percent loss of conductance. What are the differences between the two plant drought indicators? Are the results different depending on the water balance model?</li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>